// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * ACRAccessToken returns a Azure Container Registry token that can be used for pushing/pulling images. Note: by default it will return an ACR Refresh Token with full access (depending on the identity). This can be scoped down to the repository level using .spec.scope. In case scope is defined it will return an ACR Access Token. 
 See docs: https://github.com/Azure/acr/blob/main/docs/AAD-OAuth.md
 *
 * @schema ACRAccessToken
 */
export class AcrAccessToken extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ACRAccessToken"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'generators.external-secrets.io/v1alpha1',
    kind: 'ACRAccessToken',
  }

  /**
   * Renders a Kubernetes manifest for "ACRAccessToken".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AcrAccessTokenProps = {}): any {
    return {
      ...AcrAccessToken.GVK,
      ...toJson_AcrAccessTokenProps(props),
    };
  }

  /**
   * Defines a "ACRAccessToken" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AcrAccessTokenProps = {}) {
    super(scope, id, {
      ...AcrAccessToken.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...AcrAccessToken.GVK,
      ...toJson_AcrAccessTokenProps(resolved),
    };
  }
}

/**
 * ACRAccessToken returns a Azure Container Registry token that can be used for pushing/pulling images. Note: by default it will return an ACR Refresh Token with full access (depending on the identity). This can be scoped down to the repository level using .spec.scope. In case scope is defined it will return an ACR Access Token.
 * See docs: https://github.com/Azure/acr/blob/main/docs/AAD-OAuth.md
 *
 * @schema ACRAccessToken
 */
export interface AcrAccessTokenProps {
  /**
   * @schema ACRAccessToken#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ACRAccessTokenSpec defines how to generate the access token e.g. how to authenticate and which registry to use. see: https://github.com/Azure/acr/blob/main/docs/AAD-OAuth.md#overview
   *
   * @schema ACRAccessToken#spec
   */
  readonly spec?: AcrAccessTokenSpec;

}

/**
 * Converts an object of type 'AcrAccessTokenProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AcrAccessTokenProps(obj: AcrAccessTokenProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AcrAccessTokenSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ACRAccessTokenSpec defines how to generate the access token e.g. how to authenticate and which registry to use. see: https://github.com/Azure/acr/blob/main/docs/AAD-OAuth.md#overview
 *
 * @schema AcrAccessTokenSpec
 */
export interface AcrAccessTokenSpec {
  /**
   * @schema AcrAccessTokenSpec#auth
   */
  readonly auth: AcrAccessTokenSpecAuth;

  /**
   * EnvironmentType specifies the Azure cloud environment endpoints to use for connecting and authenticating with Azure. By default it points to the public cloud AAD endpoint. The following endpoints are available, also see here: https://github.com/Azure/go-autorest/blob/main/autorest/azure/environments.go#L152 PublicCloud, USGovernmentCloud, ChinaCloud, GermanCloud
   *
   * @schema AcrAccessTokenSpec#environmentType
   */
  readonly environmentType?: AcrAccessTokenSpecEnvironmentType;

  /**
   * the domain name of the ACR registry e.g. foobarexample.azurecr.io
   *
   * @schema AcrAccessTokenSpec#registry
   */
  readonly registry: string;

  /**
   * Define the scope for the access token, e.g. pull/push access for a repository. if not provided it will return a refresh token that has full scope. Note: you need to pin it down to the repository level, there is no wildcard available.
   * examples: repository:my-repository:pull,push repository:my-repository:pull
   * see docs for details: https://docs.docker.com/registry/spec/auth/scope/
   *
   * @schema AcrAccessTokenSpec#scope
   */
  readonly scope?: string;

  /**
   * TenantID configures the Azure Tenant to send requests to. Required for ServicePrincipal auth type.
   *
   * @schema AcrAccessTokenSpec#tenantId
   */
  readonly tenantId?: string;

}

/**
 * Converts an object of type 'AcrAccessTokenSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AcrAccessTokenSpec(obj: AcrAccessTokenSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_AcrAccessTokenSpecAuth(obj.auth),
    'environmentType': obj.environmentType,
    'registry': obj.registry,
    'scope': obj.scope,
    'tenantId': obj.tenantId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema AcrAccessTokenSpecAuth
 */
export interface AcrAccessTokenSpecAuth {
  /**
   * ManagedIdentity uses Azure Managed Identity to authenticate with Azure.
   *
   * @schema AcrAccessTokenSpecAuth#managedIdentity
   */
  readonly managedIdentity?: AcrAccessTokenSpecAuthManagedIdentity;

  /**
   * ServicePrincipal uses Azure Service Principal credentials to authenticate with Azure.
   *
   * @schema AcrAccessTokenSpecAuth#servicePrincipal
   */
  readonly servicePrincipal?: AcrAccessTokenSpecAuthServicePrincipal;

  /**
   * WorkloadIdentity uses Azure Workload Identity to authenticate with Azure.
   *
   * @schema AcrAccessTokenSpecAuth#workloadIdentity
   */
  readonly workloadIdentity?: AcrAccessTokenSpecAuthWorkloadIdentity;

}

/**
 * Converts an object of type 'AcrAccessTokenSpecAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AcrAccessTokenSpecAuth(obj: AcrAccessTokenSpecAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'managedIdentity': toJson_AcrAccessTokenSpecAuthManagedIdentity(obj.managedIdentity),
    'servicePrincipal': toJson_AcrAccessTokenSpecAuthServicePrincipal(obj.servicePrincipal),
    'workloadIdentity': toJson_AcrAccessTokenSpecAuthWorkloadIdentity(obj.workloadIdentity),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EnvironmentType specifies the Azure cloud environment endpoints to use for connecting and authenticating with Azure. By default it points to the public cloud AAD endpoint. The following endpoints are available, also see here: https://github.com/Azure/go-autorest/blob/main/autorest/azure/environments.go#L152 PublicCloud, USGovernmentCloud, ChinaCloud, GermanCloud
 *
 * @schema AcrAccessTokenSpecEnvironmentType
 */
export enum AcrAccessTokenSpecEnvironmentType {
  /** PublicCloud */
  PUBLIC_CLOUD = "PublicCloud",
  /** USGovernmentCloud */
  US_GOVERNMENT_CLOUD = "USGovernmentCloud",
  /** ChinaCloud */
  CHINA_CLOUD = "ChinaCloud",
  /** GermanCloud */
  GERMAN_CLOUD = "GermanCloud",
}

/**
 * ManagedIdentity uses Azure Managed Identity to authenticate with Azure.
 *
 * @schema AcrAccessTokenSpecAuthManagedIdentity
 */
export interface AcrAccessTokenSpecAuthManagedIdentity {
  /**
   * If multiple Managed Identity is assigned to the pod, you can select the one to be used
   *
   * @schema AcrAccessTokenSpecAuthManagedIdentity#identityId
   */
  readonly identityId?: string;

}

/**
 * Converts an object of type 'AcrAccessTokenSpecAuthManagedIdentity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AcrAccessTokenSpecAuthManagedIdentity(obj: AcrAccessTokenSpecAuthManagedIdentity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'identityId': obj.identityId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ServicePrincipal uses Azure Service Principal credentials to authenticate with Azure.
 *
 * @schema AcrAccessTokenSpecAuthServicePrincipal
 */
export interface AcrAccessTokenSpecAuthServicePrincipal {
  /**
   * Configuration used to authenticate with Azure using static credentials stored in a Kind=Secret.
   *
   * @schema AcrAccessTokenSpecAuthServicePrincipal#secretRef
   */
  readonly secretRef: AcrAccessTokenSpecAuthServicePrincipalSecretRef;

}

/**
 * Converts an object of type 'AcrAccessTokenSpecAuthServicePrincipal' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AcrAccessTokenSpecAuthServicePrincipal(obj: AcrAccessTokenSpecAuthServicePrincipal | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_AcrAccessTokenSpecAuthServicePrincipalSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WorkloadIdentity uses Azure Workload Identity to authenticate with Azure.
 *
 * @schema AcrAccessTokenSpecAuthWorkloadIdentity
 */
export interface AcrAccessTokenSpecAuthWorkloadIdentity {
  /**
   * ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.
   *
   * @schema AcrAccessTokenSpecAuthWorkloadIdentity#serviceAccountRef
   */
  readonly serviceAccountRef?: AcrAccessTokenSpecAuthWorkloadIdentityServiceAccountRef;

}

/**
 * Converts an object of type 'AcrAccessTokenSpecAuthWorkloadIdentity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AcrAccessTokenSpecAuthWorkloadIdentity(obj: AcrAccessTokenSpecAuthWorkloadIdentity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'serviceAccountRef': toJson_AcrAccessTokenSpecAuthWorkloadIdentityServiceAccountRef(obj.serviceAccountRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Configuration used to authenticate with Azure using static credentials stored in a Kind=Secret.
 *
 * @schema AcrAccessTokenSpecAuthServicePrincipalSecretRef
 */
export interface AcrAccessTokenSpecAuthServicePrincipalSecretRef {
  /**
   * The Azure clientId of the service principle used for authentication.
   *
   * @schema AcrAccessTokenSpecAuthServicePrincipalSecretRef#clientId
   */
  readonly clientId?: AcrAccessTokenSpecAuthServicePrincipalSecretRefClientId;

  /**
   * The Azure ClientSecret of the service principle used for authentication.
   *
   * @schema AcrAccessTokenSpecAuthServicePrincipalSecretRef#clientSecret
   */
  readonly clientSecret?: AcrAccessTokenSpecAuthServicePrincipalSecretRefClientSecret;

}

/**
 * Converts an object of type 'AcrAccessTokenSpecAuthServicePrincipalSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AcrAccessTokenSpecAuthServicePrincipalSecretRef(obj: AcrAccessTokenSpecAuthServicePrincipalSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientId': toJson_AcrAccessTokenSpecAuthServicePrincipalSecretRefClientId(obj.clientId),
    'clientSecret': toJson_AcrAccessTokenSpecAuthServicePrincipalSecretRefClientSecret(obj.clientSecret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.
 *
 * @schema AcrAccessTokenSpecAuthWorkloadIdentityServiceAccountRef
 */
export interface AcrAccessTokenSpecAuthWorkloadIdentityServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
   *
   * @schema AcrAccessTokenSpecAuthWorkloadIdentityServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema AcrAccessTokenSpecAuthWorkloadIdentityServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema AcrAccessTokenSpecAuthWorkloadIdentityServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'AcrAccessTokenSpecAuthWorkloadIdentityServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AcrAccessTokenSpecAuthWorkloadIdentityServiceAccountRef(obj: AcrAccessTokenSpecAuthWorkloadIdentityServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Azure clientId of the service principle used for authentication.
 *
 * @schema AcrAccessTokenSpecAuthServicePrincipalSecretRefClientId
 */
export interface AcrAccessTokenSpecAuthServicePrincipalSecretRefClientId {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema AcrAccessTokenSpecAuthServicePrincipalSecretRefClientId#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema AcrAccessTokenSpecAuthServicePrincipalSecretRefClientId#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema AcrAccessTokenSpecAuthServicePrincipalSecretRefClientId#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'AcrAccessTokenSpecAuthServicePrincipalSecretRefClientId' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AcrAccessTokenSpecAuthServicePrincipalSecretRefClientId(obj: AcrAccessTokenSpecAuthServicePrincipalSecretRefClientId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The Azure ClientSecret of the service principle used for authentication.
 *
 * @schema AcrAccessTokenSpecAuthServicePrincipalSecretRefClientSecret
 */
export interface AcrAccessTokenSpecAuthServicePrincipalSecretRefClientSecret {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema AcrAccessTokenSpecAuthServicePrincipalSecretRefClientSecret#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema AcrAccessTokenSpecAuthServicePrincipalSecretRefClientSecret#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema AcrAccessTokenSpecAuthServicePrincipalSecretRefClientSecret#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'AcrAccessTokenSpecAuthServicePrincipalSecretRefClientSecret' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_AcrAccessTokenSpecAuthServicePrincipalSecretRefClientSecret(obj: AcrAccessTokenSpecAuthServicePrincipalSecretRefClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * ECRAuthorizationTokenSpec uses the GetAuthorizationToken API to retrieve an authorization token. The authorization token is valid for 12 hours. The authorizationToken returned is a base64 encoded string that can be decoded and used in a docker login command to authenticate to a registry. For more information, see Registry authentication (https://docs.aws.amazon.com/AmazonECR/latest/userguide/Registries.html#registry_auth) in the Amazon Elastic Container Registry User Guide.
 *
 * @schema ECRAuthorizationToken
 */
export class EcrAuthorizationToken extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ECRAuthorizationToken"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'generators.external-secrets.io/v1alpha1',
    kind: 'ECRAuthorizationToken',
  }

  /**
   * Renders a Kubernetes manifest for "ECRAuthorizationToken".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: EcrAuthorizationTokenProps = {}): any {
    return {
      ...EcrAuthorizationToken.GVK,
      ...toJson_EcrAuthorizationTokenProps(props),
    };
  }

  /**
   * Defines a "ECRAuthorizationToken" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: EcrAuthorizationTokenProps = {}) {
    super(scope, id, {
      ...EcrAuthorizationToken.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...EcrAuthorizationToken.GVK,
      ...toJson_EcrAuthorizationTokenProps(resolved),
    };
  }
}

/**
 * ECRAuthorizationTokenSpec uses the GetAuthorizationToken API to retrieve an authorization token. The authorization token is valid for 12 hours. The authorizationToken returned is a base64 encoded string that can be decoded and used in a docker login command to authenticate to a registry. For more information, see Registry authentication (https://docs.aws.amazon.com/AmazonECR/latest/userguide/Registries.html#registry_auth) in the Amazon Elastic Container Registry User Guide.
 *
 * @schema ECRAuthorizationToken
 */
export interface EcrAuthorizationTokenProps {
  /**
   * @schema ECRAuthorizationToken#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema ECRAuthorizationToken#spec
   */
  readonly spec?: EcrAuthorizationTokenSpec;

}

/**
 * Converts an object of type 'EcrAuthorizationTokenProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EcrAuthorizationTokenProps(obj: EcrAuthorizationTokenProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_EcrAuthorizationTokenSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema EcrAuthorizationTokenSpec
 */
export interface EcrAuthorizationTokenSpec {
  /**
   * Auth defines how to authenticate with AWS
   *
   * @schema EcrAuthorizationTokenSpec#auth
   */
  readonly auth?: EcrAuthorizationTokenSpecAuth;

  /**
   * Region specifies the region to operate in.
   *
   * @schema EcrAuthorizationTokenSpec#region
   */
  readonly region: string;

  /**
   * You can assume a role before making calls to the desired AWS service.
   *
   * @schema EcrAuthorizationTokenSpec#role
   */
  readonly role?: string;

}

/**
 * Converts an object of type 'EcrAuthorizationTokenSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EcrAuthorizationTokenSpec(obj: EcrAuthorizationTokenSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_EcrAuthorizationTokenSpecAuth(obj.auth),
    'region': obj.region,
    'role': obj.role,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Auth defines how to authenticate with AWS
 *
 * @schema EcrAuthorizationTokenSpecAuth
 */
export interface EcrAuthorizationTokenSpecAuth {
  /**
   * Authenticate against AWS using service account tokens.
   *
   * @schema EcrAuthorizationTokenSpecAuth#jwt
   */
  readonly jwt?: EcrAuthorizationTokenSpecAuthJwt;

  /**
   * AWSAuthSecretRef holds secret references for AWS credentials both AccessKeyID and SecretAccessKey must be defined in order to properly authenticate.
   *
   * @schema EcrAuthorizationTokenSpecAuth#secretRef
   */
  readonly secretRef?: EcrAuthorizationTokenSpecAuthSecretRef;

}

/**
 * Converts an object of type 'EcrAuthorizationTokenSpecAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EcrAuthorizationTokenSpecAuth(obj: EcrAuthorizationTokenSpecAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'jwt': toJson_EcrAuthorizationTokenSpecAuthJwt(obj.jwt),
    'secretRef': toJson_EcrAuthorizationTokenSpecAuthSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Authenticate against AWS using service account tokens.
 *
 * @schema EcrAuthorizationTokenSpecAuthJwt
 */
export interface EcrAuthorizationTokenSpecAuthJwt {
  /**
   * A reference to a ServiceAccount resource.
   *
   * @schema EcrAuthorizationTokenSpecAuthJwt#serviceAccountRef
   */
  readonly serviceAccountRef?: EcrAuthorizationTokenSpecAuthJwtServiceAccountRef;

}

/**
 * Converts an object of type 'EcrAuthorizationTokenSpecAuthJwt' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EcrAuthorizationTokenSpecAuthJwt(obj: EcrAuthorizationTokenSpecAuthJwt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'serviceAccountRef': toJson_EcrAuthorizationTokenSpecAuthJwtServiceAccountRef(obj.serviceAccountRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AWSAuthSecretRef holds secret references for AWS credentials both AccessKeyID and SecretAccessKey must be defined in order to properly authenticate.
 *
 * @schema EcrAuthorizationTokenSpecAuthSecretRef
 */
export interface EcrAuthorizationTokenSpecAuthSecretRef {
  /**
   * The AccessKeyID is used for authentication
   *
   * @schema EcrAuthorizationTokenSpecAuthSecretRef#accessKeyIDSecretRef
   */
  readonly accessKeyIdSecretRef?: EcrAuthorizationTokenSpecAuthSecretRefAccessKeyIdSecretRef;

  /**
   * The SecretAccessKey is used for authentication
   *
   * @schema EcrAuthorizationTokenSpecAuthSecretRef#secretAccessKeySecretRef
   */
  readonly secretAccessKeySecretRef?: EcrAuthorizationTokenSpecAuthSecretRefSecretAccessKeySecretRef;

  /**
   * The SessionToken used for authentication This must be defined if AccessKeyID and SecretAccessKey are temporary credentials see: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html
   *
   * @schema EcrAuthorizationTokenSpecAuthSecretRef#sessionTokenSecretRef
   */
  readonly sessionTokenSecretRef?: EcrAuthorizationTokenSpecAuthSecretRefSessionTokenSecretRef;

}

/**
 * Converts an object of type 'EcrAuthorizationTokenSpecAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EcrAuthorizationTokenSpecAuthSecretRef(obj: EcrAuthorizationTokenSpecAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessKeyIDSecretRef': toJson_EcrAuthorizationTokenSpecAuthSecretRefAccessKeyIdSecretRef(obj.accessKeyIdSecretRef),
    'secretAccessKeySecretRef': toJson_EcrAuthorizationTokenSpecAuthSecretRefSecretAccessKeySecretRef(obj.secretAccessKeySecretRef),
    'sessionTokenSecretRef': toJson_EcrAuthorizationTokenSpecAuthSecretRefSessionTokenSecretRef(obj.sessionTokenSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to a ServiceAccount resource.
 *
 * @schema EcrAuthorizationTokenSpecAuthJwtServiceAccountRef
 */
export interface EcrAuthorizationTokenSpecAuthJwtServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
   *
   * @schema EcrAuthorizationTokenSpecAuthJwtServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema EcrAuthorizationTokenSpecAuthJwtServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema EcrAuthorizationTokenSpecAuthJwtServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'EcrAuthorizationTokenSpecAuthJwtServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EcrAuthorizationTokenSpecAuthJwtServiceAccountRef(obj: EcrAuthorizationTokenSpecAuthJwtServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The AccessKeyID is used for authentication
 *
 * @schema EcrAuthorizationTokenSpecAuthSecretRefAccessKeyIdSecretRef
 */
export interface EcrAuthorizationTokenSpecAuthSecretRefAccessKeyIdSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema EcrAuthorizationTokenSpecAuthSecretRefAccessKeyIdSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema EcrAuthorizationTokenSpecAuthSecretRefAccessKeyIdSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema EcrAuthorizationTokenSpecAuthSecretRefAccessKeyIdSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'EcrAuthorizationTokenSpecAuthSecretRefAccessKeyIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EcrAuthorizationTokenSpecAuthSecretRefAccessKeyIdSecretRef(obj: EcrAuthorizationTokenSpecAuthSecretRefAccessKeyIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The SecretAccessKey is used for authentication
 *
 * @schema EcrAuthorizationTokenSpecAuthSecretRefSecretAccessKeySecretRef
 */
export interface EcrAuthorizationTokenSpecAuthSecretRefSecretAccessKeySecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema EcrAuthorizationTokenSpecAuthSecretRefSecretAccessKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema EcrAuthorizationTokenSpecAuthSecretRefSecretAccessKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema EcrAuthorizationTokenSpecAuthSecretRefSecretAccessKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'EcrAuthorizationTokenSpecAuthSecretRefSecretAccessKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EcrAuthorizationTokenSpecAuthSecretRefSecretAccessKeySecretRef(obj: EcrAuthorizationTokenSpecAuthSecretRefSecretAccessKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The SessionToken used for authentication This must be defined if AccessKeyID and SecretAccessKey are temporary credentials see: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html
 *
 * @schema EcrAuthorizationTokenSpecAuthSecretRefSessionTokenSecretRef
 */
export interface EcrAuthorizationTokenSpecAuthSecretRefSessionTokenSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema EcrAuthorizationTokenSpecAuthSecretRefSessionTokenSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema EcrAuthorizationTokenSpecAuthSecretRefSessionTokenSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema EcrAuthorizationTokenSpecAuthSecretRefSessionTokenSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'EcrAuthorizationTokenSpecAuthSecretRefSessionTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_EcrAuthorizationTokenSpecAuthSecretRefSessionTokenSecretRef(obj: EcrAuthorizationTokenSpecAuthSecretRefSessionTokenSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * Fake generator is used for testing. It lets you define a static set of credentials that is always returned.
 *
 * @schema Fake
 */
export class Fake extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Fake"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'generators.external-secrets.io/v1alpha1',
    kind: 'Fake',
  }

  /**
   * Renders a Kubernetes manifest for "Fake".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: FakeProps = {}): any {
    return {
      ...Fake.GVK,
      ...toJson_FakeProps(props),
    };
  }

  /**
   * Defines a "Fake" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: FakeProps = {}) {
    super(scope, id, {
      ...Fake.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Fake.GVK,
      ...toJson_FakeProps(resolved),
    };
  }
}

/**
 * Fake generator is used for testing. It lets you define a static set of credentials that is always returned.
 *
 * @schema Fake
 */
export interface FakeProps {
  /**
   * @schema Fake#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * FakeSpec contains the static data.
   *
   * @schema Fake#spec
   */
  readonly spec?: FakeSpec;

}

/**
 * Converts an object of type 'FakeProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FakeProps(obj: FakeProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_FakeSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * FakeSpec contains the static data.
 *
 * @schema FakeSpec
 */
export interface FakeSpec {
  /**
   * Data defines the static data returned by this generator.
   *
   * @schema FakeSpec#data
   */
  readonly data?: { [key: string]: string };

}

/**
 * Converts an object of type 'FakeSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FakeSpec(obj: FakeSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'data': ((obj.data) === undefined) ? undefined : (Object.entries(obj.data).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * GCRAccessToken generates an GCP access token that can be used to authenticate with GCR.
 *
 * @schema GCRAccessToken
 */
export class GcrAccessToken extends ApiObject {
  /**
   * Returns the apiVersion and kind for "GCRAccessToken"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'generators.external-secrets.io/v1alpha1',
    kind: 'GCRAccessToken',
  }

  /**
   * Renders a Kubernetes manifest for "GCRAccessToken".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: GcrAccessTokenProps = {}): any {
    return {
      ...GcrAccessToken.GVK,
      ...toJson_GcrAccessTokenProps(props),
    };
  }

  /**
   * Defines a "GCRAccessToken" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: GcrAccessTokenProps = {}) {
    super(scope, id, {
      ...GcrAccessToken.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...GcrAccessToken.GVK,
      ...toJson_GcrAccessTokenProps(resolved),
    };
  }
}

/**
 * GCRAccessToken generates an GCP access token that can be used to authenticate with GCR.
 *
 * @schema GCRAccessToken
 */
export interface GcrAccessTokenProps {
  /**
   * @schema GCRAccessToken#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema GCRAccessToken#spec
   */
  readonly spec?: GcrAccessTokenSpec;

}

/**
 * Converts an object of type 'GcrAccessTokenProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GcrAccessTokenProps(obj: GcrAccessTokenProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_GcrAccessTokenSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GcrAccessTokenSpec
 */
export interface GcrAccessTokenSpec {
  /**
   * Auth defines the means for authenticating with GCP
   *
   * @schema GcrAccessTokenSpec#auth
   */
  readonly auth: GcrAccessTokenSpecAuth;

  /**
   * ProjectID defines which project to use to authenticate with
   *
   * @schema GcrAccessTokenSpec#projectID
   */
  readonly projectId: string;

}

/**
 * Converts an object of type 'GcrAccessTokenSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GcrAccessTokenSpec(obj: GcrAccessTokenSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_GcrAccessTokenSpecAuth(obj.auth),
    'projectID': obj.projectId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Auth defines the means for authenticating with GCP
 *
 * @schema GcrAccessTokenSpecAuth
 */
export interface GcrAccessTokenSpecAuth {
  /**
   * @schema GcrAccessTokenSpecAuth#secretRef
   */
  readonly secretRef?: GcrAccessTokenSpecAuthSecretRef;

  /**
   * @schema GcrAccessTokenSpecAuth#workloadIdentity
   */
  readonly workloadIdentity?: GcrAccessTokenSpecAuthWorkloadIdentity;

}

/**
 * Converts an object of type 'GcrAccessTokenSpecAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GcrAccessTokenSpecAuth(obj: GcrAccessTokenSpecAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_GcrAccessTokenSpecAuthSecretRef(obj.secretRef),
    'workloadIdentity': toJson_GcrAccessTokenSpecAuthWorkloadIdentity(obj.workloadIdentity),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GcrAccessTokenSpecAuthSecretRef
 */
export interface GcrAccessTokenSpecAuthSecretRef {
  /**
   * The SecretAccessKey is used for authentication
   *
   * @schema GcrAccessTokenSpecAuthSecretRef#secretAccessKeySecretRef
   */
  readonly secretAccessKeySecretRef?: GcrAccessTokenSpecAuthSecretRefSecretAccessKeySecretRef;

}

/**
 * Converts an object of type 'GcrAccessTokenSpecAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GcrAccessTokenSpecAuthSecretRef(obj: GcrAccessTokenSpecAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretAccessKeySecretRef': toJson_GcrAccessTokenSpecAuthSecretRefSecretAccessKeySecretRef(obj.secretAccessKeySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema GcrAccessTokenSpecAuthWorkloadIdentity
 */
export interface GcrAccessTokenSpecAuthWorkloadIdentity {
  /**
   * @schema GcrAccessTokenSpecAuthWorkloadIdentity#clusterLocation
   */
  readonly clusterLocation: string;

  /**
   * @schema GcrAccessTokenSpecAuthWorkloadIdentity#clusterName
   */
  readonly clusterName: string;

  /**
   * @schema GcrAccessTokenSpecAuthWorkloadIdentity#clusterProjectID
   */
  readonly clusterProjectId?: string;

  /**
   * A reference to a ServiceAccount resource.
   *
   * @schema GcrAccessTokenSpecAuthWorkloadIdentity#serviceAccountRef
   */
  readonly serviceAccountRef: GcrAccessTokenSpecAuthWorkloadIdentityServiceAccountRef;

}

/**
 * Converts an object of type 'GcrAccessTokenSpecAuthWorkloadIdentity' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GcrAccessTokenSpecAuthWorkloadIdentity(obj: GcrAccessTokenSpecAuthWorkloadIdentity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterLocation': obj.clusterLocation,
    'clusterName': obj.clusterName,
    'clusterProjectID': obj.clusterProjectId,
    'serviceAccountRef': toJson_GcrAccessTokenSpecAuthWorkloadIdentityServiceAccountRef(obj.serviceAccountRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The SecretAccessKey is used for authentication
 *
 * @schema GcrAccessTokenSpecAuthSecretRefSecretAccessKeySecretRef
 */
export interface GcrAccessTokenSpecAuthSecretRefSecretAccessKeySecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema GcrAccessTokenSpecAuthSecretRefSecretAccessKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema GcrAccessTokenSpecAuthSecretRefSecretAccessKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema GcrAccessTokenSpecAuthSecretRefSecretAccessKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'GcrAccessTokenSpecAuthSecretRefSecretAccessKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GcrAccessTokenSpecAuthSecretRefSecretAccessKeySecretRef(obj: GcrAccessTokenSpecAuthSecretRefSecretAccessKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A reference to a ServiceAccount resource.
 *
 * @schema GcrAccessTokenSpecAuthWorkloadIdentityServiceAccountRef
 */
export interface GcrAccessTokenSpecAuthWorkloadIdentityServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
   *
   * @schema GcrAccessTokenSpecAuthWorkloadIdentityServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema GcrAccessTokenSpecAuthWorkloadIdentityServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema GcrAccessTokenSpecAuthWorkloadIdentityServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'GcrAccessTokenSpecAuthWorkloadIdentityServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_GcrAccessTokenSpecAuthWorkloadIdentityServiceAccountRef(obj: GcrAccessTokenSpecAuthWorkloadIdentityServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * Password generates a random password based on the configuration parameters in spec. You can specify the length, characterset and other attributes.
 *
 * @schema Password
 */
export class Password extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Password"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'generators.external-secrets.io/v1alpha1',
    kind: 'Password',
  }

  /**
   * Renders a Kubernetes manifest for "Password".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PasswordProps = {}): any {
    return {
      ...Password.GVK,
      ...toJson_PasswordProps(props),
    };
  }

  /**
   * Defines a "Password" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PasswordProps = {}) {
    super(scope, id, {
      ...Password.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Password.GVK,
      ...toJson_PasswordProps(resolved),
    };
  }
}

/**
 * Password generates a random password based on the configuration parameters in spec. You can specify the length, characterset and other attributes.
 *
 * @schema Password
 */
export interface PasswordProps {
  /**
   * @schema Password#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * PasswordSpec controls the behavior of the password generator.
   *
   * @schema Password#spec
   */
  readonly spec?: PasswordSpec;

}

/**
 * Converts an object of type 'PasswordProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PasswordProps(obj: PasswordProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PasswordSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PasswordSpec controls the behavior of the password generator.
 *
 * @schema PasswordSpec
 */
export interface PasswordSpec {
  /**
   * set AllowRepeat to true to allow repeating characters.
   *
   * @schema PasswordSpec#allowRepeat
   */
  readonly allowRepeat: boolean;

  /**
   * Digits specifies the number of digits in the generated password. If omitted it defaults to 25% of the length of the password
   *
   * @schema PasswordSpec#digits
   */
  readonly digits?: number;

  /**
   * Length of the password to be generated. Defaults to 24
   *
   * @default 24
   * @schema PasswordSpec#length
   */
  readonly length: number;

  /**
   * Set NoUpper to disable uppercase characters
   *
   * @schema PasswordSpec#noUpper
   */
  readonly noUpper: boolean;

  /**
   * SymbolCharacters specifies the special characters that should be used in the generated password.
   *
   * @schema PasswordSpec#symbolCharacters
   */
  readonly symbolCharacters?: string;

  /**
   * Symbols specifies the number of symbol characters in the generated password. If omitted it defaults to 25% of the length of the password
   *
   * @schema PasswordSpec#symbols
   */
  readonly symbols?: number;

}

/**
 * Converts an object of type 'PasswordSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PasswordSpec(obj: PasswordSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowRepeat': obj.allowRepeat,
    'digits': obj.digits,
    'length': obj.length,
    'noUpper': obj.noUpper,
    'symbolCharacters': obj.symbolCharacters,
    'symbols': obj.symbols,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Component describes an Dapr component type
 *
 * @schema Component
 */
export class Component extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Component"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'dapr.io/v1alpha1',
    kind: 'Component',
  }

  /**
   * Renders a Kubernetes manifest for "Component".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ComponentProps = {}): any {
    return {
      ...Component.GVK,
      ...toJson_ComponentProps(props),
    };
  }

  /**
   * Defines a "Component" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ComponentProps = {}) {
    super(scope, id, {
      ...Component.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Component.GVK,
      ...toJson_ComponentProps(resolved),
    };
  }
}

/**
 * Component describes an Dapr component type
 *
 * @schema Component
 */
export interface ComponentProps {
  /**
   * @schema Component#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Auth represents authentication details for the component
   *
   * @schema Component#auth
   */
  readonly auth?: ComponentAuth;

  /**
   * @schema Component#scopes
   */
  readonly scopes?: string[];

  /**
   * ComponentSpec is the spec for a component
   *
   * @schema Component#spec
   */
  readonly spec?: ComponentSpec;

}

/**
 * Converts an object of type 'ComponentProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComponentProps(obj: ComponentProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'auth': toJson_ComponentAuth(obj.auth),
    'scopes': obj.scopes?.map(y => y),
    'spec': toJson_ComponentSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Auth represents authentication details for the component
 *
 * @schema ComponentAuth
 */
export interface ComponentAuth {
  /**
   * @schema ComponentAuth#secretStore
   */
  readonly secretStore: string;

}

/**
 * Converts an object of type 'ComponentAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComponentAuth(obj: ComponentAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretStore': obj.secretStore,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ComponentSpec is the spec for a component
 *
 * @schema ComponentSpec
 */
export interface ComponentSpec {
  /**
   * @schema ComponentSpec#ignoreErrors
   */
  readonly ignoreErrors?: boolean;

  /**
   * @schema ComponentSpec#initTimeout
   */
  readonly initTimeout?: string;

  /**
   * @schema ComponentSpec#metadata
   */
  readonly metadata: ComponentSpecMetadata[];

  /**
   * @schema ComponentSpec#type
   */
  readonly type: string;

  /**
   * @schema ComponentSpec#version
   */
  readonly version: string;

}

/**
 * Converts an object of type 'ComponentSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComponentSpec(obj: ComponentSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ignoreErrors': obj.ignoreErrors,
    'initTimeout': obj.initTimeout,
    'metadata': obj.metadata?.map(y => toJson_ComponentSpecMetadata(y)),
    'type': obj.type,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * MetadataItem is a name/value pair for a metadata
 *
 * @schema ComponentSpecMetadata
 */
export interface ComponentSpecMetadata {
  /**
   * @schema ComponentSpecMetadata#name
   */
  readonly name: string;

  /**
   * SecretKeyRef is a reference to a secret holding the value for the metadata item. Name is the secret name, and key is the field in the secret.
   *
   * @schema ComponentSpecMetadata#secretKeyRef
   */
  readonly secretKeyRef?: ComponentSpecMetadataSecretKeyRef;

  /**
   * @schema ComponentSpecMetadata#value
   */
  readonly value?: any;

}

/**
 * Converts an object of type 'ComponentSpecMetadata' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComponentSpecMetadata(obj: ComponentSpecMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'secretKeyRef': toJson_ComponentSpecMetadataSecretKeyRef(obj.secretKeyRef),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretKeyRef is a reference to a secret holding the value for the metadata item. Name is the secret name, and key is the field in the secret.
 *
 * @schema ComponentSpecMetadataSecretKeyRef
 */
export interface ComponentSpecMetadataSecretKeyRef {
  /**
   * @schema ComponentSpecMetadataSecretKeyRef#key
   */
  readonly key: string;

  /**
   * @schema ComponentSpecMetadataSecretKeyRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ComponentSpecMetadataSecretKeyRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ComponentSpecMetadataSecretKeyRef(obj: ComponentSpecMetadataSecretKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * Configuration describes an Dapr configuration setting
 *
 * @schema Configuration
 */
export class Configuration extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Configuration"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'dapr.io/v1alpha1',
    kind: 'Configuration',
  }

  /**
   * Renders a Kubernetes manifest for "Configuration".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ConfigurationProps = {}): any {
    return {
      ...Configuration.GVK,
      ...toJson_ConfigurationProps(props),
    };
  }

  /**
   * Defines a "Configuration" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ConfigurationProps = {}) {
    super(scope, id, {
      ...Configuration.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Configuration.GVK,
      ...toJson_ConfigurationProps(resolved),
    };
  }
}

/**
 * Configuration describes an Dapr configuration setting
 *
 * @schema Configuration
 */
export interface ConfigurationProps {
  /**
   * @schema Configuration#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ConfigurationSpec is the spec for an configuration
   *
   * @schema Configuration#spec
   */
  readonly spec?: ConfigurationSpec;

}

/**
 * Converts an object of type 'ConfigurationProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationProps(obj: ConfigurationProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ConfigurationSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigurationSpec is the spec for an configuration
 *
 * @schema ConfigurationSpec
 */
export interface ConfigurationSpec {
  /**
   * AccessControlSpec is the spec object in ConfigurationSpec
   *
   * @schema ConfigurationSpec#accessControl
   */
  readonly accessControl?: ConfigurationSpecAccessControl;

  /**
   * PipelineSpec defines the middleware pipeline
   *
   * @schema ConfigurationSpec#httpPipeline
   */
  readonly httpPipeline?: ConfigurationSpecHttpPipeline;

  /**
   * MetricSpec defines metrics configuration
   *
   * @schema ConfigurationSpec#metric
   */
  readonly metric?: ConfigurationSpecMetric;

  /**
   * MTLSSpec defines mTLS configuration
   *
   * @schema ConfigurationSpec#mtls
   */
  readonly mtls?: ConfigurationSpecMtls;

  /**
   * SecretsSpec is the spec for secrets configuration
   *
   * @schema ConfigurationSpec#secrets
   */
  readonly secrets?: ConfigurationSpecSecrets;

  /**
   * TracingSpec is the spec object in ConfigurationSpec
   *
   * @schema ConfigurationSpec#tracing
   */
  readonly tracing?: ConfigurationSpecTracing;

}

/**
 * Converts an object of type 'ConfigurationSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSpec(obj: ConfigurationSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessControl': toJson_ConfigurationSpecAccessControl(obj.accessControl),
    'httpPipeline': toJson_ConfigurationSpecHttpPipeline(obj.httpPipeline),
    'metric': toJson_ConfigurationSpecMetric(obj.metric),
    'mtls': toJson_ConfigurationSpecMtls(obj.mtls),
    'secrets': toJson_ConfigurationSpecSecrets(obj.secrets),
    'tracing': toJson_ConfigurationSpecTracing(obj.tracing),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AccessControlSpec is the spec object in ConfigurationSpec
 *
 * @schema ConfigurationSpecAccessControl
 */
export interface ConfigurationSpecAccessControl {
  /**
   * @schema ConfigurationSpecAccessControl#defaultAction
   */
  readonly defaultAction?: string;

  /**
   * @schema ConfigurationSpecAccessControl#policies
   */
  readonly policies?: ConfigurationSpecAccessControlPolicies[];

  /**
   * @schema ConfigurationSpecAccessControl#trustDomain
   */
  readonly trustDomain?: string;

}

/**
 * Converts an object of type 'ConfigurationSpecAccessControl' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSpecAccessControl(obj: ConfigurationSpecAccessControl | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'defaultAction': obj.defaultAction,
    'policies': obj.policies?.map(y => toJson_ConfigurationSpecAccessControlPolicies(y)),
    'trustDomain': obj.trustDomain,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PipelineSpec defines the middleware pipeline
 *
 * @schema ConfigurationSpecHttpPipeline
 */
export interface ConfigurationSpecHttpPipeline {
  /**
   * @schema ConfigurationSpecHttpPipeline#handlers
   */
  readonly handlers: ConfigurationSpecHttpPipelineHandlers[];

}

/**
 * Converts an object of type 'ConfigurationSpecHttpPipeline' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSpecHttpPipeline(obj: ConfigurationSpecHttpPipeline | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'handlers': obj.handlers?.map(y => toJson_ConfigurationSpecHttpPipelineHandlers(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * MetricSpec defines metrics configuration
 *
 * @schema ConfigurationSpecMetric
 */
export interface ConfigurationSpecMetric {
  /**
   * @schema ConfigurationSpecMetric#enabled
   */
  readonly enabled: boolean;

}

/**
 * Converts an object of type 'ConfigurationSpecMetric' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSpecMetric(obj: ConfigurationSpecMetric | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * MTLSSpec defines mTLS configuration
 *
 * @schema ConfigurationSpecMtls
 */
export interface ConfigurationSpecMtls {
  /**
   * @schema ConfigurationSpecMtls#allowedClockSkew
   */
  readonly allowedClockSkew?: string;

  /**
   * @schema ConfigurationSpecMtls#enabled
   */
  readonly enabled: boolean;

  /**
   * @schema ConfigurationSpecMtls#workloadCertTTL
   */
  readonly workloadCertTtl?: string;

}

/**
 * Converts an object of type 'ConfigurationSpecMtls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSpecMtls(obj: ConfigurationSpecMtls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedClockSkew': obj.allowedClockSkew,
    'enabled': obj.enabled,
    'workloadCertTTL': obj.workloadCertTtl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretsSpec is the spec for secrets configuration
 *
 * @schema ConfigurationSpecSecrets
 */
export interface ConfigurationSpecSecrets {
  /**
   * @schema ConfigurationSpecSecrets#scopes
   */
  readonly scopes: ConfigurationSpecSecretsScopes[];

}

/**
 * Converts an object of type 'ConfigurationSpecSecrets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSpecSecrets(obj: ConfigurationSpecSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'scopes': obj.scopes?.map(y => toJson_ConfigurationSpecSecretsScopes(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TracingSpec is the spec object in ConfigurationSpec
 *
 * @schema ConfigurationSpecTracing
 */
export interface ConfigurationSpecTracing {
  /**
   * @schema ConfigurationSpecTracing#samplingRate
   */
  readonly samplingRate: string;

  /**
   * Defines the Zipkin trace configurations
   *
   * @schema ConfigurationSpecTracing#zipkin
   */
  readonly zipkin?: ConfigurationSpecTracingZipkin;

}

/**
 * Converts an object of type 'ConfigurationSpecTracing' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSpecTracing(obj: ConfigurationSpecTracing | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'samplingRate': obj.samplingRate,
    'zipkin': toJson_ConfigurationSpecTracingZipkin(obj.zipkin),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AppPolicySpec defines the policy data structure for each app
 *
 * @schema ConfigurationSpecAccessControlPolicies
 */
export interface ConfigurationSpecAccessControlPolicies {
  /**
   * @schema ConfigurationSpecAccessControlPolicies#appId
   */
  readonly appId: string;

  /**
   * @schema ConfigurationSpecAccessControlPolicies#defaultAction
   */
  readonly defaultAction?: string;

  /**
   * @schema ConfigurationSpecAccessControlPolicies#namespace
   */
  readonly namespace?: string;

  /**
   * @schema ConfigurationSpecAccessControlPolicies#operations
   */
  readonly operations?: ConfigurationSpecAccessControlPoliciesOperations[];

  /**
   * @schema ConfigurationSpecAccessControlPolicies#trustDomain
   */
  readonly trustDomain?: string;

}

/**
 * Converts an object of type 'ConfigurationSpecAccessControlPolicies' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSpecAccessControlPolicies(obj: ConfigurationSpecAccessControlPolicies | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appId': obj.appId,
    'defaultAction': obj.defaultAction,
    'namespace': obj.namespace,
    'operations': obj.operations?.map(y => toJson_ConfigurationSpecAccessControlPoliciesOperations(y)),
    'trustDomain': obj.trustDomain,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HandlerSpec defines a request handlers
 *
 * @schema ConfigurationSpecHttpPipelineHandlers
 */
export interface ConfigurationSpecHttpPipelineHandlers {
  /**
   * @schema ConfigurationSpecHttpPipelineHandlers#name
   */
  readonly name: string;

  /**
   * SelectorSpec selects target services to which the handler is to be applied
   *
   * @schema ConfigurationSpecHttpPipelineHandlers#selector
   */
  readonly selector?: ConfigurationSpecHttpPipelineHandlersSelector;

  /**
   * @schema ConfigurationSpecHttpPipelineHandlers#type
   */
  readonly type: string;

}

/**
 * Converts an object of type 'ConfigurationSpecHttpPipelineHandlers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSpecHttpPipelineHandlers(obj: ConfigurationSpecHttpPipelineHandlers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'selector': toJson_ConfigurationSpecHttpPipelineHandlersSelector(obj.selector),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecretsScope defines the scope for secrets
 *
 * @schema ConfigurationSpecSecretsScopes
 */
export interface ConfigurationSpecSecretsScopes {
  /**
   * @schema ConfigurationSpecSecretsScopes#allowedSecrets
   */
  readonly allowedSecrets?: string[];

  /**
   * @schema ConfigurationSpecSecretsScopes#defaultAccess
   */
  readonly defaultAccess?: string;

  /**
   * @schema ConfigurationSpecSecretsScopes#deniedSecrets
   */
  readonly deniedSecrets?: string[];

  /**
   * @schema ConfigurationSpecSecretsScopes#storeName
   */
  readonly storeName: string;

}

/**
 * Converts an object of type 'ConfigurationSpecSecretsScopes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSpecSecretsScopes(obj: ConfigurationSpecSecretsScopes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowedSecrets': obj.allowedSecrets?.map(y => y),
    'defaultAccess': obj.defaultAccess,
    'deniedSecrets': obj.deniedSecrets?.map(y => y),
    'storeName': obj.storeName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Defines the Zipkin trace configurations
 *
 * @schema ConfigurationSpecTracingZipkin
 */
export interface ConfigurationSpecTracingZipkin {
  /**
   * The endpoint address of Zipkin server to receive traces
   *
   * @schema ConfigurationSpecTracingZipkin#endpointAddress
   */
  readonly endpointAddress?: string;

}

/**
 * Converts an object of type 'ConfigurationSpecTracingZipkin' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSpecTracingZipkin(obj: ConfigurationSpecTracingZipkin | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'endpointAddress': obj.endpointAddress,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AppOperationAction defines the data structure for each app operation
 *
 * @schema ConfigurationSpecAccessControlPoliciesOperations
 */
export interface ConfigurationSpecAccessControlPoliciesOperations {
  /**
   * @schema ConfigurationSpecAccessControlPoliciesOperations#action
   */
  readonly action: string;

  /**
   * @schema ConfigurationSpecAccessControlPoliciesOperations#httpVerb
   */
  readonly httpVerb?: string[];

  /**
   * @schema ConfigurationSpecAccessControlPoliciesOperations#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ConfigurationSpecAccessControlPoliciesOperations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSpecAccessControlPoliciesOperations(obj: ConfigurationSpecAccessControlPoliciesOperations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'httpVerb': obj.httpVerb?.map(y => y),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SelectorSpec selects target services to which the handler is to be applied
 *
 * @schema ConfigurationSpecHttpPipelineHandlersSelector
 */
export interface ConfigurationSpecHttpPipelineHandlersSelector {
  /**
   * @schema ConfigurationSpecHttpPipelineHandlersSelector#fields
   */
  readonly fields: ConfigurationSpecHttpPipelineHandlersSelectorFields[];

}

/**
 * Converts an object of type 'ConfigurationSpecHttpPipelineHandlersSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSpecHttpPipelineHandlersSelector(obj: ConfigurationSpecHttpPipelineHandlersSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fields': obj.fields?.map(y => toJson_ConfigurationSpecHttpPipelineHandlersSelectorFields(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SelectorField defines a selector fields
 *
 * @schema ConfigurationSpecHttpPipelineHandlersSelectorFields
 */
export interface ConfigurationSpecHttpPipelineHandlersSelectorFields {
  /**
   * @schema ConfigurationSpecHttpPipelineHandlersSelectorFields#field
   */
  readonly field: string;

  /**
   * @schema ConfigurationSpecHttpPipelineHandlersSelectorFields#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ConfigurationSpecHttpPipelineHandlersSelectorFields' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ConfigurationSpecHttpPipelineHandlersSelectorFields(obj: ConfigurationSpecHttpPipelineHandlersSelectorFields | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'field': obj.field,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * Subscription describes an pub/sub event subscription
 *
 * @schema Subscription
 */
export class Subscription extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Subscription"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'dapr.io/v1alpha1',
    kind: 'Subscription',
  }

  /**
   * Renders a Kubernetes manifest for "Subscription".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: SubscriptionProps = {}): any {
    return {
      ...Subscription.GVK,
      ...toJson_SubscriptionProps(props),
    };
  }

  /**
   * Defines a "Subscription" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: SubscriptionProps = {}) {
    super(scope, id, {
      ...Subscription.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Subscription.GVK,
      ...toJson_SubscriptionProps(resolved),
    };
  }
}

/**
 * Subscription describes an pub/sub event subscription
 *
 * @schema Subscription
 */
export interface SubscriptionProps {
  /**
   * @schema Subscription#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema Subscription#scopes
   */
  readonly scopes?: string[];

  /**
   * SubscriptionSpec is the spec for an event subscription
   *
   * @schema Subscription#spec
   */
  readonly spec?: SubscriptionSpec;

}

/**
 * Converts an object of type 'SubscriptionProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubscriptionProps(obj: SubscriptionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'scopes': obj.scopes?.map(y => y),
    'spec': toJson_SubscriptionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SubscriptionSpec is the spec for an event subscription
 *
 * @schema SubscriptionSpec
 */
export interface SubscriptionSpec {
  /**
   * @schema SubscriptionSpec#pubsubname
   */
  readonly pubsubname: string;

  /**
   * @schema SubscriptionSpec#route
   */
  readonly route: string;

  /**
   * @schema SubscriptionSpec#topic
   */
  readonly topic: string;

}

/**
 * Converts an object of type 'SubscriptionSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_SubscriptionSpec(obj: SubscriptionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pubsubname': obj.pubsubname,
    'route': obj.route,
    'topic': obj.topic,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

